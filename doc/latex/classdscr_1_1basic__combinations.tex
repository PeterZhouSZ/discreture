\hypertarget{classdscr_1_1basic__combinations}{\section{dscr\-:\-:basic\-\_\-combinations$<$ Int\-Type $>$ Class Template Reference}
\label{classdscr_1_1basic__combinations}\index{dscr\-::basic\-\_\-combinations$<$ Int\-Type $>$@{dscr\-::basic\-\_\-combinations$<$ Int\-Type $>$}}
}


class of all n choose k combinations of size k of the set \{0,1,...,n-\/1\}.  




{\ttfamily \#include $<$Combinations.\-hpp$>$}

\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classdscr_1_1basic__combinations_1_1iterator}{iterator}
\begin{DoxyCompactList}\small\item\em Random access iterator class. It's much more efficient as a bidirectional iterator than purely random access. \end{DoxyCompactList}\item 
class \hyperlink{classdscr_1_1basic__combinations_1_1reverse__iterator}{reverse\-\_\-iterator}
\begin{DoxyCompactList}\small\item\em Reverse random access iterator class. It's much more efficient as a bidirectional iterator than purely random access. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classdscr_1_1basic__combinations_a1e2009c3ffa76ac7c4e18016abbd920d}{typedef long long int {\bfseries difference\-\_\-type}}\label{classdscr_1_1basic__combinations_a1e2009c3ffa76ac7c4e18016abbd920d}

\item 
\hypertarget{classdscr_1_1basic__combinations_a93972e9ce95005164c165c5ecfcb1b41}{typedef unsigned long long int {\bfseries size\-\_\-type}}\label{classdscr_1_1basic__combinations_a93972e9ce95005164c165c5ecfcb1b41}

\item 
\hypertarget{classdscr_1_1basic__combinations_a7fe2516646aab1845fe75b5b6e31e264}{typedef vector$<$ Int\-Type $>$ {\bfseries value\-\_\-type}}\label{classdscr_1_1basic__combinations_a7fe2516646aab1845fe75b5b6e31e264}

\item 
\hypertarget{classdscr_1_1basic__combinations_aad2a97982e0824740f2ac07a07c51863}{typedef vector$<$ Int\-Type $>$ {\bfseries combination}}\label{classdscr_1_1basic__combinations_aad2a97982e0824740f2ac07a07c51863}

\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classdscr_1_1basic__combinations_a0a1c805efc25a065b1f64af7a9e526ca}{basic\-\_\-combinations} (Int\-Type n, Int\-Type k)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
size\-\_\-type \hyperlink{classdscr_1_1basic__combinations_aad12129d764245f4fbae5d777d97228d}{size} () const 
\begin{DoxyCompactList}\small\item\em The total number of combinations. \end{DoxyCompactList}\item 
size\-\_\-type \hyperlink{classdscr_1_1basic__combinations_a3d36156a1aa2ba156696ce8a6569ce70}{get\-\_\-index} (const combination \&comb) const 
\begin{DoxyCompactList}\small\item\em Returns the I\-D of the iterator whose value is comb. That is, the index of combination comb in the lexicographic order. \end{DoxyCompactList}\item 
\hypertarget{classdscr_1_1basic__combinations_ab715609621f607ea0353bcda589e4f47}{Int\-Type {\bfseries get\-\_\-n} () const }\label{classdscr_1_1basic__combinations_ab715609621f607ea0353bcda589e4f47}

\item 
\hypertarget{classdscr_1_1basic__combinations_a7a57a2f9b82d1d8bf7205ba1672e97ca}{Int\-Type {\bfseries get\-\_\-k} () const }\label{classdscr_1_1basic__combinations_a7a57a2f9b82d1d8bf7205ba1672e97ca}

\item 
\hypertarget{classdscr_1_1basic__combinations_adcf9e7e0c890ecfdbe7b9982fba4b104}{\hyperlink{classdscr_1_1basic__combinations_1_1iterator}{iterator} {\bfseries get\-\_\-iterator} (const combination \&comb)}\label{classdscr_1_1basic__combinations_adcf9e7e0c890ecfdbe7b9982fba4b104}

\item 
\hypertarget{classdscr_1_1basic__combinations_ae08cabc1dfbce46ec31b495a02c60286}{const \hyperlink{classdscr_1_1basic__combinations_1_1iterator}{iterator} \& {\bfseries begin} () const }\label{classdscr_1_1basic__combinations_ae08cabc1dfbce46ec31b495a02c60286}

\item 
\hypertarget{classdscr_1_1basic__combinations_a363123791c4628aac82efd5f07258aa4}{const \hyperlink{classdscr_1_1basic__combinations_1_1iterator}{iterator} \& {\bfseries end} () const }\label{classdscr_1_1basic__combinations_a363123791c4628aac82efd5f07258aa4}

\item 
\hypertarget{classdscr_1_1basic__combinations_a702fb964db92de71732119a2931f9660}{const \hyperlink{classdscr_1_1basic__combinations_1_1reverse__iterator}{reverse\-\_\-iterator} \& {\bfseries rbegin} () const }\label{classdscr_1_1basic__combinations_a702fb964db92de71732119a2931f9660}

\item 
\hypertarget{classdscr_1_1basic__combinations_a686ea9a981e7119b04e944649bd92d5d}{const \hyperlink{classdscr_1_1basic__combinations_1_1reverse__iterator}{reverse\-\_\-iterator} \& {\bfseries rend} () const }\label{classdscr_1_1basic__combinations_a686ea9a981e7119b04e944649bd92d5d}

\item 
combination \hyperlink{classdscr_1_1basic__combinations_a6e064851e71942f39ada8e5d669df441}{operator\mbox{[}$\,$\mbox{]}} (size\-\_\-type m) const 
\begin{DoxyCompactList}\small\item\em Access to the m-\/th combination (slow for iteration) \end{DoxyCompactList}\item 
{\footnotesize template$<$class Partial\-Predicate $>$ }\\\hyperlink{classdscr_1_1basic__combinations_1_1iterator}{iterator} \hyperlink{classdscr_1_1basic__combinations_ae14b7a1e2f723a7697402d69e8bb1095}{find\-\_\-if} (Partial\-Predicate pred)
\begin{DoxyCompactList}\small\item\em This is an efficient way to construct a combination of size k which fully satisfies a predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Partial\-Predicate $>$ }\\vector$<$ combination $>$ \hyperlink{classdscr_1_1basic__combinations_a3f536b237cc48cdf74a85de956201233}{find\-\_\-all} (Partial\-Predicate pred)
\begin{DoxyCompactList}\small\item\em This is an efficient way to construct all combination of size k which fully satisfy a predicate. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classdscr_1_1basic__combinations_ab82571265bfa7eb54d5f003932a2cb51}{static Int\-Type {\bfseries next\-\_\-combination} (combination \&data, Int\-Type hint=0)}\label{classdscr_1_1basic__combinations_ab82571265bfa7eb54d5f003932a2cb51}

\item 
\hypertarget{classdscr_1_1basic__combinations_ad120a0ed8dd6b229d75d1f7d6f830fca}{static void {\bfseries prev\-\_\-combination} (combination \&data)}\label{classdscr_1_1basic__combinations_ad120a0ed8dd6b229d75d1f7d6f830fca}

\item 
\hypertarget{classdscr_1_1basic__combinations_ab7f0bd474342742eba6ff522bf8589ee}{static void {\bfseries construct\-\_\-combination} (combination \&data, size\-\_\-type m)}\label{classdscr_1_1basic__combinations_ab7f0bd474342742eba6ff522bf8589ee}

\item 
static bool \hyperlink{classdscr_1_1basic__combinations_aa02c3a340a08313d851bca27aa571ba0}{compare} (const combination \&lhs, const combination \&rhs)
\begin{DoxyCompactList}\small\item\em Combination comparison \char`\"{}less than\char`\"{} operator. Assumes lhs and rhs have the same size. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class Int\-Type$>$class dscr\-::basic\-\_\-combinations$<$ Int\-Type $>$}

class of all n choose k combinations of size k of the set \{0,1,...,n-\/1\}. 


\begin{DoxyParams}{Parameters}
{\em Int\-Type} & should be an integral type with enough space to store n and k. It can be signed or unsigned. \\
\hline
{\em n} & the size of the set \\
\hline
{\em k} & the size of the combination (subset). Should be an integer such that n choose k is not bigger than the largest unsigned long int there is. For example, typically 50 choose 25 is already larger than the largest long unsigned int. \subsection*{Example\-:}\\
\hline
\end{DoxyParams}
\begin{DoxyVerb}combinations X(6,3);
for (const auto& x : X)
    cout << x << " ";
\end{DoxyVerb}


Prints out\-: \begin{DoxyVerb}[ 0 1 2 ] [ 0 1 3 ] [ 0 2 3 ] [ 1 2 3 ] [ 0 1 4 ] [ 0 2 4 ] [ 1 2 4 ] [ 0 3 4 ] [ 1 3 4 ] [ 2 3 4 ] [ 0 1 5 ] [ 0 2 5 ] [ 1 2 5 ] [ 0 3 5 ] [ 1 3 5 ] [ 2 3 5 ] [ 0 4 5 ] [ 1 4 5 ] [ 2 4 5 ] [ 3 4 5 ]
\end{DoxyVerb}


\subsection*{Example 2\-:}

\begin{DoxyVerb}basic_combinations<short int> X(5,1);
for (const auto& x : X)
    cout << x << " ";
Prints out:
    [0] [1] [2] [3] [4]
\end{DoxyVerb}


\subsection*{Example 3\-:}

\begin{DoxyVerb}string A = "helloworld";
combinations X(A.size(),2);
for (const auto& x : X)
{
    auto b = compose(A,x);
    cout << b << "-";
}

Prints out:
    he-hl-el-hl-el-ll-ho-eo-lo-lo-hw-ew-lw-lw-ow-ho-eo-lo-lo-oo-wo-hr-er-lr-lr-or-wr-or-hl-el-ll-ll-ol-wl-ol-rl-hd-ed-ld-ld-od-wd-od-rd-ld-\end{DoxyVerb}
 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classdscr_1_1basic__combinations_a0a1c805efc25a065b1f64af7a9e526ca}{\index{dscr\-::basic\-\_\-combinations@{dscr\-::basic\-\_\-combinations}!basic\-\_\-combinations@{basic\-\_\-combinations}}
\index{basic\-\_\-combinations@{basic\-\_\-combinations}!dscr::basic_combinations@{dscr\-::basic\-\_\-combinations}}
\subsubsection[{basic\-\_\-combinations}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Int\-Type $>$ {\bf dscr\-::basic\-\_\-combinations}$<$ Int\-Type $>$\-::{\bf basic\-\_\-combinations} (
\begin{DoxyParamCaption}
\item[{Int\-Type}]{n, }
\item[{Int\-Type}]{k}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classdscr_1_1basic__combinations_a0a1c805efc25a065b1f64af7a9e526ca}


Constructor. 


\begin{DoxyParams}{Parameters}
{\em n} & is an integer $>$= 0 \\
\hline
{\em k} & is an integer with 0 $<$= k $<$= n \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\hypertarget{classdscr_1_1basic__combinations_aa02c3a340a08313d851bca27aa571ba0}{\index{dscr\-::basic\-\_\-combinations@{dscr\-::basic\-\_\-combinations}!compare@{compare}}
\index{compare@{compare}!dscr::basic_combinations@{dscr\-::basic\-\_\-combinations}}
\subsubsection[{compare}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Int\-Type $>$ static bool {\bf dscr\-::basic\-\_\-combinations}$<$ Int\-Type $>$\-::compare (
\begin{DoxyParamCaption}
\item[{const combination \&}]{lhs, }
\item[{const combination \&}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}}\label{classdscr_1_1basic__combinations_aa02c3a340a08313d851bca27aa571ba0}


Combination comparison \char`\"{}less than\char`\"{} operator. Assumes lhs and rhs have the same size. 

\begin{DoxyReturn}{Returns}
true if lhs would appear before rhs in the normal iteration order, false otherwise 
\end{DoxyReturn}
\hypertarget{classdscr_1_1basic__combinations_a3f536b237cc48cdf74a85de956201233}{\index{dscr\-::basic\-\_\-combinations@{dscr\-::basic\-\_\-combinations}!find\-\_\-all@{find\-\_\-all}}
\index{find\-\_\-all@{find\-\_\-all}!dscr::basic_combinations@{dscr\-::basic\-\_\-combinations}}
\subsubsection[{find\-\_\-all}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Int\-Type $>$ template$<$class Partial\-Predicate $>$ vector$<$combination$>$ {\bf dscr\-::basic\-\_\-combinations}$<$ Int\-Type $>$\-::find\-\_\-all (
\begin{DoxyParamCaption}
\item[{Partial\-Predicate}]{pred}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classdscr_1_1basic__combinations_a3f536b237cc48cdf74a85de956201233}


This is an efficient way to construct all combination of size k which fully satisfy a predicate. 

This function is similar to find\-\_\-if, but it returns a vector with all combinations which satisfy pred,

\subsection*{Example\-:}

\begin{DoxyVerb}combinations X(10,5);
auto vall = X.find_all([](const vector<int>& comb) -> bool
{
    for (int i = 0; i < comb.size()-1; ++i)
    {
        if (comb[i]+1 == comb[i+1])
            return false;
    }
    return true;
});
for (const auto& v : vall)
    cout << v << endl;
\end{DoxyVerb}


Prints out\-: \mbox{[} 0 2 4 6 8 \mbox{]} \mbox{[} 0 2 4 6 9 \mbox{]} \mbox{[} 0 2 4 7 9 \mbox{]} \mbox{[} 0 2 5 7 9 \mbox{]} \mbox{[} 0 3 5 7 9 \mbox{]} \mbox{[} 1 3 5 7 9 \mbox{]} which are all combinations which don't contain two consecutive elements


\begin{DoxyParams}{Parameters}
{\em Pred} & should be what we call a {\itshape partial predicate}\-: It takes a combination as a parameter and returns either true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An vector$<$combination$>$ filled will all permutations which fully satisfy the predicate.
\end{DoxyReturn}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000001}{Todo}]Perhaps one should be able to iterate over all such permutations without constructing a vector of them!\end{DoxyRefDesc}
\hypertarget{classdscr_1_1basic__combinations_ae14b7a1e2f723a7697402d69e8bb1095}{\index{dscr\-::basic\-\_\-combinations@{dscr\-::basic\-\_\-combinations}!find\-\_\-if@{find\-\_\-if}}
\index{find\-\_\-if@{find\-\_\-if}!dscr::basic_combinations@{dscr\-::basic\-\_\-combinations}}
\subsubsection[{find\-\_\-if}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Int\-Type $>$ template$<$class Partial\-Predicate $>$ {\bf iterator} {\bf dscr\-::basic\-\_\-combinations}$<$ Int\-Type $>$\-::find\-\_\-if (
\begin{DoxyParamCaption}
\item[{Partial\-Predicate}]{pred}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classdscr_1_1basic__combinations_ae14b7a1e2f723a7697402d69e8bb1095}


This is an efficient way to construct a combination of size k which fully satisfies a predicate. 

This function is conceptually equivalent to std\-::find\-\_\-if(begin(), end(), Pred), but much faster if the predicate can be evaluated on a partial combination (so as to prune the search tree)

\subsection*{Example\-:}

\begin{DoxyVerb}combinations X(40,6);
auto it = X.find_if([](const vector<int>& comb) -> bool
{
    for (int i = 0; i < comb.size()-1; ++i)
    {
        if (2*comb[i] + 1 > comb[i+1])
            return false;
    }
    return true;
});
cout << *it << endl;
\end{DoxyVerb}


Prints out\-: \mbox{[} 0 1 3 7 15 31 \mbox{]}


\begin{DoxyParams}{Parameters}
{\em Pred} & should be what we call a {\itshape partial predicate}\-: It takes a combination as a parameter and returns either true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An interator to a combination which fully satisfies the predicate. 
\end{DoxyReturn}
\hypertarget{classdscr_1_1basic__combinations_a3d36156a1aa2ba156696ce8a6569ce70}{\index{dscr\-::basic\-\_\-combinations@{dscr\-::basic\-\_\-combinations}!get\-\_\-index@{get\-\_\-index}}
\index{get\-\_\-index@{get\-\_\-index}!dscr::basic_combinations@{dscr\-::basic\-\_\-combinations}}
\subsubsection[{get\-\_\-index}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Int\-Type $>$ size\-\_\-type {\bf dscr\-::basic\-\_\-combinations}$<$ Int\-Type $>$\-::get\-\_\-index (
\begin{DoxyParamCaption}
\item[{const combination \&}]{comb}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classdscr_1_1basic__combinations_a3d36156a1aa2ba156696ce8a6569ce70}


Returns the I\-D of the iterator whose value is comb. That is, the index of combination comb in the lexicographic order. 

Inverse of operator\mbox{[}\mbox{]}. If combination x is the m-\/th combination, then get\-\_\-index(x) is m. If one has a combinations\-::iterator, then the member function I\-D() should return the same value. \begin{DoxyReturn}{Returns}
the index of combination comb, as if \hyperlink{classdscr_1_1basic__combinations}{basic\-\_\-combinations} was a proper data structure 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This constructs the proper index from scratch. If an iterator is already known, calling I\-D on the iterator is much more efficient. 
\end{DoxyNote}
\hypertarget{classdscr_1_1basic__combinations_a6e064851e71942f39ada8e5d669df441}{\index{dscr\-::basic\-\_\-combinations@{dscr\-::basic\-\_\-combinations}!operator\mbox{[}$\,$\mbox{]}@{operator[]}}
\index{operator\mbox{[}$\,$\mbox{]}@{operator[]}!dscr::basic_combinations@{dscr\-::basic\-\_\-combinations}}
\subsubsection[{operator[]}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Int\-Type $>$ combination {\bf dscr\-::basic\-\_\-combinations}$<$ Int\-Type $>$\-::operator\mbox{[}$\,$\mbox{]} (
\begin{DoxyParamCaption}
\item[{size\-\_\-type}]{m}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classdscr_1_1basic__combinations_a6e064851e71942f39ada8e5d669df441}


Access to the m-\/th combination (slow for iteration) 

This is equivalent to calling $\ast$(begin()+m) 
\begin{DoxyParams}{Parameters}
{\em m} & should be an integer between 0 and \hyperlink{classdscr_1_1basic__combinations_aad12129d764245f4fbae5d777d97228d}{size()}. Undefined behavior otherwise. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The m-\/th combination, as defined in the order of iteration (lexicographic) 
\end{DoxyReturn}
\hypertarget{classdscr_1_1basic__combinations_aad12129d764245f4fbae5d777d97228d}{\index{dscr\-::basic\-\_\-combinations@{dscr\-::basic\-\_\-combinations}!size@{size}}
\index{size@{size}!dscr::basic_combinations@{dscr\-::basic\-\_\-combinations}}
\subsubsection[{size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Int\-Type $>$ size\-\_\-type {\bf dscr\-::basic\-\_\-combinations}$<$ Int\-Type $>$\-::size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classdscr_1_1basic__combinations_aad12129d764245f4fbae5d777d97228d}


The total number of combinations. 

\begin{DoxyReturn}{Returns}
binomial(n,r) 
\end{DoxyReturn}


The documentation for this class was generated from the following file\-:\begin{DoxyCompactItemize}
\item 
Combinations.\-hpp\end{DoxyCompactItemize}
