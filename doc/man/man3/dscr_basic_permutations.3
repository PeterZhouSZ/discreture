.TH "dscr::basic_permutations< IntType >" 3 "Fri Feb 26 2016" "Version 1" "discreture" \" -*- nroff -*-
.ad l
.nh
.SH NAME
dscr::basic_permutations< IntType > \- 
.PP
class of all n! permutation of size n of the set {0,1,\&.\&.\&.,n-1}\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Permutations\&.hpp>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBiterator\fP"
.br
.RI "\fIRandom access iterator class\&. It's much more efficient as a bidirectional iterator than purely random access\&. \fP"
.ti -1c
.RI "class \fBreverse_iterator\fP"
.br
.RI "\fIReverse random access iterator class\&. It's much more efficient as a bidirectional iterator than purely random access\&. \fP"
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef long long int \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef unsigned long long int \fBsize_type\fP"
.br
.ti -1c
.RI "typedef vector< IntType > \fBvalue_type\fP"
.br
.ti -1c
.RI "typedef vector< IntType > \fBpermutation\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBbasic_permutations\fP (IntType n)"
.br
.RI "\fIConstructor\&. \fP"
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.RI "\fIThe total number of permutations\&. \fP"
.ti -1c
.RI "permutation \fBidentity\fP () const "
.br
.RI "\fIReturns the identity permutation: [1, 2, 3, \&.\&.\&. , (n-1)]\&. \fP"
.ti -1c
.RI "permutation \fBrandom\fP () const "
.br
.RI "\fIConstructs a random permutation of {0,1,2,\&.\&.\&.,n-1}\&. \fP"
.ti -1c
.RI "size_type \fBget_index\fP (const permutation &perm, size_t start=0)"
.br
.RI "\fIReturns the ID of the iterator whose value is perm\&. That is, the index of permutation perm in the lexicographic order\&. \fP"
.ti -1c
.RI "const \fBiterator\fP & \fBbegin\fP () const "
.br
.ti -1c
.RI "const \fBiterator\fP & \fBend\fP () const "
.br
.ti -1c
.RI "const \fBreverse_iterator\fP & \fBrbegin\fP () const "
.br
.ti -1c
.RI "const \fBreverse_iterator\fP & \fBrend\fP () const "
.br
.ti -1c
.RI "permutation \fBoperator[]\fP (size_type m) const "
.br
.RI "\fIAccess to the m-th permutation (slow for iteration) \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBconstruct_permutation\fP (permutation &data, size_type m)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class IntType>class dscr::basic_permutations< IntType >"
class of all n! permutation of size n of the set {0,1,\&.\&.\&.,n-1}\&. 


.PP
\fBParameters:\fP
.RS 4
\fIIntType\fP should be an integral type with enough space to store n and k\&. It can be signed or unsigned\&. 
.br
\fIn\fP should be an integer <= 20, since 20! already exceeds the numeric limits of a long unsigned int C++ 
.SH "Example:"
.PP
.RE
.PP
.PP
.nf
permutations X(3);
for (const auto& x : X)
    cout << x << " ";

Prints out:
    [ 0 1 2 ] [ 0 2 1 ] [ 1 0 2 ] [ 1 2 0 ] [ 2 0 1 ] [ 2 1 0 ] 
.fi
.PP
.PP
.SH "Example 3:"
.PP
.PP
.PP
.nf
string A = "abc";
permutations X(A.size());
for (const auto& x : X)
{
    auto b = compose(A,x);
    cout << b << "-";
}
.fi
.PP
.PP
Prints out: abc-acb-bac-bca-cab-cba- 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class IntType > \fBdscr::basic_permutations\fP< IntType >::\fBbasic_permutations\fP (IntTypen)\fC [inline]\fP"

.PP
Constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP is an integer >= 0 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<class IntType > size_type \fBdscr::basic_permutations\fP< IntType >::get_index (const permutation &perm, size_tstart = \fC0\fP)\fC [inline]\fP"

.PP
Returns the ID of the iterator whose value is perm\&. That is, the index of permutation perm in the lexicographic order\&. Inverse of operator[]\&. If permutation x is the m-th permutation, then get_index(x) is m\&. If one has a permutations::iterator, then the member function ID() should return the same value\&. 
.PP
\fBReturns:\fP
.RS 4
the index of permutation comb, as if \fBbasic_permutations\fP was a proper data structure 
.RE
.PP
\fBNote:\fP
.RS 4
This constructs the proper index from scratch\&. If an iterator is already known, calling ID() on the iterator is much more efficient\&. 
.RE
.PP

.SS "template<class IntType > permutation \fBdscr::basic_permutations\fP< IntType >::identity () const\fC [inline]\fP"

.PP
Returns the identity permutation: [1, 2, 3, \&.\&.\&. , (n-1)]\&. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP is an integer >= 0 
.RE
.PP

.SS "template<class IntType > permutation \fBdscr::basic_permutations\fP< IntType >::operator[] (size_typem) const\fC [inline]\fP"

.PP
Access to the m-th permutation (slow for iteration) This is equivalent to calling *(begin()+m) 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP should be an integer between 0 and \fBsize()\fP\&. Undefined behavior otherwise\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The m-th permutation, as defined in the order of iteration (lexicographic) 
.RE
.PP

.SS "template<class IntType > size_type \fBdscr::basic_permutations\fP< IntType >::size () const\fC [inline]\fP"

.PP
The total number of permutations\&. 
.PP
\fBReturns:\fP
.RS 4
n! 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for discreture from the source code\&.
