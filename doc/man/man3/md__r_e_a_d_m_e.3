.TH "md__r_e_a_d_m_e" 3 "Wed Mar 16 2016" "Version 1" "discreture" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md__r_e_a_d_m_e \- Discreture 
This is a modern C++ 11 (and 14) library designed to facilitate combinatorial research by providing fast and easy iterators to a few combinatorial objects, such as combinations, permutations, partitions, and others\&. The idea is to have them resemble the STL containers as much as possible, without actually storing the whole set of objects in memory\&.
.PP
Discreture is designed to follow the STL containers as closely as possible, by providing the standard ways of iterating\&. In addition, many of the algorithms described in the standard <algorithm> library work as-is in these containers, as if the containers were constant\&.
.PP
.SH "Quick preview:"
.PP
.PP
```c++ #include <iostream> #include 'discreture\&.hpp' using namespace std; using namespace dscr; int main() { combinations X(5,3); for (const auto& x : X) cout << x << endl; return 0; } ``` The above code would produce the following output: 
.PP
.nf
[ 0 1 2 ]
[ 0 1 3 ]
[ 0 2 3 ]
[ 1 2 3 ]
[ 0 1 4 ]
[ 0 2 4 ]
[ 1 2 4 ]
[ 0 3 4 ]
[ 1 3 4 ]
[ 2 3 4 ]

.fi
.PP
.PP
Of course, you need to link with the discreture library: g++ -O3 -ldiscreture main\&.cpp
.PP
Some tests show discreture is usually faster when compiled with clang++ instead of g++\&.
.PP
.SH "Installation"
.PP
.PP
To download and install on linux, run the following commands:
.PP
```sh git checkout https://github.com/mraggi/discreture.git cd discreture sh install_linux\&.sh ```
.PP
This will compile the library and copy the necessary files to /usr/lib and /usr/include\&. It will ask for your root password\&. If you just wish to compile and then link manually, do the following: ```sh git checkout https://github.com/mraggi/discreture.git cd discreture mkdir build cd build cmake \&.\&. make ``\fC Furthermore, it's recommended to compile using the clang compiler instead of gcc\&. One can do this by running\fPcmake \&.\&. -DUSE_CLANG`, or editing the CMakeLists\&.txt and switch the 'OFF' option of USE_CLANG to 'ON'\&.
.PP
You can run the tests like by running the executable: \fC\&./testdiscreture\fP
.PP
.SH "How to start using the library"
.PP
.PP
To use the library, after compiling, just add \fC#include <\fBdiscreture/discreture\&.hpp\fP>\fP (make sure this can be done) and link to \fClibdiscreture\&.so\fP\&. With the GCC compiler or CLANG, this can be done by compiling like this: \fCg++ -ldiscreture myfile\&.cpp\fP
.PP
.SH "Combinatorial Objects"
.PP
.PP
Within this library, one can construct a few combinatorial objects, such as:
.IP "\(bu" 2
Combinations
.IP "\(bu" 2
Permutations
.IP "\(bu" 2
Subsets
.IP "\(bu" 2
Multisets
.IP "\(bu" 2
Partitions
.IP "\(bu" 2
Dyck Paths
.IP "\(bu" 2
Motzkin Paths
.IP "\(bu" 2
Range
.IP "\(bu" 2
Set Partitions
.PP
.PP
All follow the same design principle: The templated class is calles basic_SOMETHING<class T>, and the most reasonable type for T is instantiated as SOMETHING\&. For example, \fCcombinations\fP is a typedef of \fCbasic_combinations<int>\fP, and \fCpartitions\fP is a typedef of \fCbasic_partitions<int>\fP, following the standard string design: std::string is actually a typedef of std::basic_string<char>\&.
.PP
.SH "Advanced use"
.PP
.PP
Although the full reference is in the doxygen documentation, here is a quick preview\&. Remember to always \fC#include 'discreture\&.hpp'\fP (or \fC#include <\fBdiscreture/discreture\&.hpp\fP>\fP etc\&.):
.PP
```c++ combinations X(30,10); for (const auto& x : X) { // x is of type const vector<int>&, so anything that works with vectors works on x } ```
.PP
You can iterate in reverse too, in the same way you would reverse-iterate an STL container\&. ```c++ combinations X(30,10); for (auto it = X\&.rbegin(); it != X\&.rend(); ++it) { const auto& x = *it; // x is of type const vector<int>&, so anything that works with vectors works on x } ```
.PP
Combinations, subsets and permutations are a random-access container (although they are slower as such than forward or reverse iteration), so something like this works too: ```c++ combinations X(30,10); for (size_t i = 0; i < X\&.size(); ++i) { auto x = X[i]; } ```
.PP
This is much slower if one plans to actually iterate over all of them, but iterator arithmetic is implemented, so one could even do the following: ```c++ #include <algorithm> combinations X(30,10); std::lower_bound(X\&.begin(), X\&.end(), predicate, combinations::compare); //TODO: FIX THIS!!!! ``\fC where\fPpredicate\fCis a unary predicate that takes a\fPconst vector<int>&` as an argument and returns true or false\&. This would effectively do binary search\&. 
